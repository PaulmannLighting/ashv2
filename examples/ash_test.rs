//! Test `ASHv2` connection.

use ashv2::{open, BaudRate, SyncAsh, Transceiver};
use clap::Parser;
use log::{error, info};
use serialport::{FlowControl, SerialPort};
use std::sync::atomic::AtomicBool;
use std::sync::atomic::Ordering::Relaxed;
use std::sync::mpsc::channel;
use std::sync::Arc;
use std::thread::spawn;

const COMMANDS: [(&[u8], &[u8]); 0x1A] = [
    // Version (legacy frame format) command
    (
        &[0x00, 0x00, 0x00, 0x04],
        &[0x00, 0x80, 0x00, 0x08, 0x02, 0x30, 0x6A],
    ),
    // Version (new frame format) command
    (
        &[0x01, 0x00, 0x01, 0x00, 0x00, 0x08],
        &[0x01, 0x80, 0x01, 0x00, 0x00, 0x08, 0x02, 0x30, 0x6A],
    ),
    // getStandaloneBootloaderVersionPlatMicroPhy command
    (
        &[0x02, 0x00, 0x01, 0x91, 0x00],
        &[0x02, 0x80, 0x01, 0x91, 0x00, 0x00, 0x1C, 0x04, 0x18, 0x0F],
    ),
    // Diverse getConfigurationValue commands
    (
        &[0x03, 0x00, 0x01, 0x52, 0x00, 0x1A],
        &[0x03, 0x80, 0x01, 0x52, 0x00, 0x00, 0xC8, 0x00],
    ),
    (
        &[0x04, 0x00, 0x01, 0x52, 0x00, 0x0D],
        &[0x04, 0x80, 0x01, 0x52, 0x00, 0x00, 0x05, 0x00],
    ),
    (
        &[0x05, 0x00, 0x01, 0x52, 0x00, 0x05],
        &[0x05, 0x80, 0x01, 0x52, 0x00, 0x00, 0x08, 0x00],
    ),
    (
        &[0x06, 0x00, 0x01, 0x52, 0x00, 0x19],
        &[0x06, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x07, 0x00, 0x01, 0x52, 0x00, 0x0C],
        &[0x07, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x08, 0x00, 0x01, 0x52, 0x00, 0x12],
        &[0x08, 0x80, 0x01, 0x52, 0x00, 0x00, 0xB8, 0x0B],
    ),
    (
        &[0x09, 0x00, 0x01, 0x52, 0x00, 0x10],
        &[0x09, 0x80, 0x01, 0x52, 0x00, 0x00, 0x1E, 0x00],
    ),
    (
        &[0x0A, 0x00, 0x01, 0x52, 0x00, 0x17],
        &[0x0A, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x0B, 0x00, 0x01, 0x52, 0x00, 0x2D],
        &[0x0B, 0x80, 0x01, 0x52, 0x00, 0x00, 0x01, 0x00],
    ),
    (
        &[0x0C, 0x00, 0x01, 0x52, 0x00, 0x1E],
        &[0x0C, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0C, 0x00],
    ),
    (
        &[0x0D, 0x00, 0x01, 0x52, 0x00, 0x2A],
        &[0x0D, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x0E, 0x00, 0x01, 0x52, 0x00, 0x11],
        &[0x0E, 0x80, 0x01, 0x52, 0x00, 0x00, 0x20, 0x00],
    ),
    (
        &[0x0F, 0x00, 0x01, 0x52, 0x00, 0x03],
        &[0x0F, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0A, 0x00],
    ),
    (
        &[0x10, 0x00, 0x01, 0x52, 0x00, 0x2B],
        &[0x10, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0F, 0x00],
    ),
    (
        &[0x11, 0x00, 0x01, 0x52, 0x00, 0x04],
        &[0x11, 0x80, 0x01, 0x52, 0x00, 0x00, 0x20, 0x00],
    ),
    (
        &[0x12, 0x00, 0x01, 0x52, 0x00, 0x02],
        &[0x12, 0x80, 0x01, 0x52, 0x00, 0x00, 0x10, 0x00],
    ),
    (
        &[0x13, 0x00, 0x01, 0x52, 0x00, 0x1C],
        &[0x13, 0x80, 0x01, 0x52, 0x00, 0x00, 0x01, 0x00],
    ),
    (
        &[0x14, 0x00, 0x01, 0x52, 0x00, 0x1D],
        &[0x14, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x15, 0x00, 0x01, 0x52, 0x00, 0x01],
        &[0x15, 0x80, 0x01, 0x52, 0x00, 0x00, 0xFA, 0x00],
    ),
    // Diverse getPolicy commands
    (
        &[0x16, 0x00, 0x01, 0x56, 0x00, 0x00],
        &[0x16, 0x80, 0x01, 0x56, 0x00, 0x00, 0x03],
    ),
    (
        &[0x17, 0x00, 0x01, 0x56, 0x00, 0x01],
        &[0x17, 0x80, 0x01, 0x56, 0x00, 0x00, 0x10],
    ),
    (
        &[0x18, 0x00, 0x01, 0x56, 0x00, 0x04],
        &[0x18, 0x80, 0x01, 0x56, 0x00, 0x00, 0x40],
    ),
    (
        &[0x19, 0x00, 0x01, 0x56, 0x00, 0x05],
        &[0x19, 0x80, 0x01, 0x56, 0x00, 0x00, 0x50],
    ),
];

const LONG_COMMAND: [u8; 256] = [0xAA; 256];

#[derive(Debug, Parser)]
struct Args {
    #[arg(index = 1)]
    tty: String,
}

struct InlineBytes<'a>(&'a [u8]);

impl std::fmt::Display for InlineBytes<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[")?;

        for (index, byte) in self.0.iter().enumerate() {
            if self.0.len().saturating_sub(1) == index {
                write!(f, "{byte:#04X}")?;
            } else {
                write!(f, "{byte:#04X}, ")?;
            }
        }

        write!(f, "]")
    }
}

fn main() {
    env_logger::init();
    let args = Args::parse();

    match open(args.tty, BaudRate::RstCts, FlowControl::Software) {
        Ok(serial_port) => run(serial_port),
        Err(error) => error!("{error}"),
    }
}

fn run(serial_port: impl SerialPort + 'static) {
    let (host, receiver) = channel();
    let transceiver = Transceiver::new(serial_port, receiver, None);
    let running = Arc::new(AtomicBool::new(true));
    let running_transceiver = running.clone();
    let _thread_handle = spawn(|| transceiver.run(running_transceiver));

    for (command, response) in COMMANDS {
        info!("Sending command: {command:#04X?}");

        match host.communicate(command) {
            Ok(bytes) => {
                info!("Got response: {}", InlineBytes(&bytes));

                if bytes.iter().as_slice() == response {
                    info!("Response matches expected response.");
                } else {
                    error!("Response does not match expected response.");
                }
            }
            Err(error) => error!("Got error: {error:?}"),
        }
    }

    match host.communicate(&LONG_COMMAND) {
        Ok(response) => info!("Got response for long command: {response:#04X?}"),
        Err(error) => error!("Got error: {error:?}"),
    }

    running.store(false, Relaxed);
}
