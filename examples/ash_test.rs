//! Test `ASHv2` connection.

use ashv2::{open, AshFramed, BaudRate, HexSlice, Transceiver};
use clap::Parser;
use futures::SinkExt;
use log::{error, info};
use serialport::{FlowControl, SerialPort};
use std::sync::atomic::AtomicBool;
use std::sync::mpsc::sync_channel;
use std::sync::Arc;
use std::thread::spawn;
use tokio_stream::StreamExt;
use tokio_util::bytes::BytesMut;
use tokio_util::codec::{Decoder, Encoder, Framed};

const COMMANDS: [(&[u8], &[u8]); 0x1A] = [
    // Version (legacy frame format) command
    (
        &[0x00, 0x00, 0x00, 0x04],
        &[0x00, 0x80, 0x00, 0x08, 0x02, 0x30, 0x6A],
    ),
    // Version (new frame format) command
    (
        &[0x01, 0x00, 0x01, 0x00, 0x00, 0x08],
        &[0x01, 0x80, 0x01, 0x00, 0x00, 0x08, 0x02, 0x30, 0x6A],
    ),
    // getStandaloneBootloaderVersionPlatMicroPhy command
    (
        &[0x02, 0x00, 0x01, 0x91, 0x00],
        &[0x02, 0x80, 0x01, 0x91, 0x00, 0x00, 0x1C, 0x04, 0x18, 0x0F],
    ),
    // Diverse getConfigurationValue commands
    (
        &[0x03, 0x00, 0x01, 0x52, 0x00, 0x1A],
        &[0x03, 0x80, 0x01, 0x52, 0x00, 0x00, 0xC8, 0x00],
    ),
    (
        &[0x04, 0x00, 0x01, 0x52, 0x00, 0x0D],
        &[0x04, 0x80, 0x01, 0x52, 0x00, 0x00, 0x05, 0x00],
    ),
    (
        &[0x05, 0x00, 0x01, 0x52, 0x00, 0x05],
        &[0x05, 0x80, 0x01, 0x52, 0x00, 0x00, 0x08, 0x00],
    ),
    (
        &[0x06, 0x00, 0x01, 0x52, 0x00, 0x19],
        &[0x06, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x07, 0x00, 0x01, 0x52, 0x00, 0x0C],
        &[0x07, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x08, 0x00, 0x01, 0x52, 0x00, 0x12],
        &[0x08, 0x80, 0x01, 0x52, 0x00, 0x00, 0xB8, 0x0B],
    ),
    (
        &[0x09, 0x00, 0x01, 0x52, 0x00, 0x10],
        &[0x09, 0x80, 0x01, 0x52, 0x00, 0x00, 0x1E, 0x00],
    ),
    (
        &[0x0A, 0x00, 0x01, 0x52, 0x00, 0x17],
        &[0x0A, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x0B, 0x00, 0x01, 0x52, 0x00, 0x2D],
        &[0x0B, 0x80, 0x01, 0x52, 0x00, 0x00, 0x01, 0x00],
    ),
    (
        &[0x0C, 0x00, 0x01, 0x52, 0x00, 0x1E],
        &[0x0C, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0C, 0x00],
    ),
    (
        &[0x0D, 0x00, 0x01, 0x52, 0x00, 0x2A],
        &[0x0D, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x0E, 0x00, 0x01, 0x52, 0x00, 0x11],
        &[0x0E, 0x80, 0x01, 0x52, 0x00, 0x00, 0x20, 0x00],
    ),
    (
        &[0x0F, 0x00, 0x01, 0x52, 0x00, 0x03],
        &[0x0F, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0A, 0x00],
    ),
    (
        &[0x10, 0x00, 0x01, 0x52, 0x00, 0x2B],
        &[0x10, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0F, 0x00],
    ),
    (
        &[0x11, 0x00, 0x01, 0x52, 0x00, 0x04],
        &[0x11, 0x80, 0x01, 0x52, 0x00, 0x00, 0x20, 0x00],
    ),
    (
        &[0x12, 0x00, 0x01, 0x52, 0x00, 0x02],
        &[0x12, 0x80, 0x01, 0x52, 0x00, 0x00, 0x10, 0x00],
    ),
    (
        &[0x13, 0x00, 0x01, 0x52, 0x00, 0x1C],
        &[0x13, 0x80, 0x01, 0x52, 0x00, 0x00, 0x01, 0x00],
    ),
    (
        &[0x14, 0x00, 0x01, 0x52, 0x00, 0x1D],
        &[0x14, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x15, 0x00, 0x01, 0x52, 0x00, 0x01],
        &[0x15, 0x80, 0x01, 0x52, 0x00, 0x00, 0xFA, 0x00],
    ),
    // Diverse getPolicy commands
    (
        &[0x16, 0x00, 0x01, 0x56, 0x00, 0x00],
        &[0x16, 0x80, 0x01, 0x56, 0x00, 0x00, 0x03],
    ),
    (
        &[0x17, 0x00, 0x01, 0x56, 0x00, 0x01],
        &[0x17, 0x80, 0x01, 0x56, 0x00, 0x00, 0x10],
    ),
    (
        &[0x18, 0x00, 0x01, 0x56, 0x00, 0x04],
        &[0x18, 0x80, 0x01, 0x56, 0x00, 0x00, 0x40],
    ),
    (
        &[0x19, 0x00, 0x01, 0x56, 0x00, 0x05],
        &[0x19, 0x80, 0x01, 0x56, 0x00, 0x00, 0x50],
    ),
];

#[derive(Debug, Parser)]
struct Args {
    #[arg(index = 1)]
    tty: String,
}

/// An example decoder.
#[derive(Debug)]
pub struct RawCodec;

impl Decoder for RawCodec {
    type Item = Box<[u8]>;
    type Error = std::io::Error;

    fn decode(&mut self, buffer: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        if buffer.len() >= 4 {
            Ok(Some(buffer.split().as_ref().into()))
        } else {
            Ok(None)
        }
    }
}

impl Encoder<Box<[u8]>> for RawCodec {
    type Error = std::io::Error;

    fn encode(&mut self, item: Box<[u8]>, dst: &mut BytesMut) -> Result<(), Self::Error> {
        dst.extend_from_slice(&item);
        Ok(())
    }
}

#[tokio::main]
async fn main() {
    env_logger::init();
    let args = Args::parse();

    match open(args.tty, BaudRate::RstCts, FlowControl::Software) {
        Ok(serial_port) => run(serial_port).await,
        Err(error) => error!("{error}"),
    }
}

async fn run(serial_port: impl SerialPort + 'static) {
    let (sender, receiver) = sync_channel(32);
    let transceiver = Transceiver::new(serial_port, receiver, None);
    let running = Arc::new(AtomicBool::new(true));
    let transceiver_thread = spawn(|| transceiver.run(running));
    let mut framed = Framed::new(AshFramed::<2>::new(sender), RawCodec);

    for (command, response) in COMMANDS {
        info!("Sending command: {:#04X}", HexSlice::new(command));

        match framed.send(command.into()).await {
            Ok(()) => {
                info!("Sent bytes: {:#04X}", HexSlice::new(command));
            }
            Err(error) => error!("Got error: {error:?}"),
        }

        if let Some(item) = framed.next().await {
            match item {
                Ok(bytes) => {
                    info!("Got response: {:#04X}", HexSlice::new(&bytes));

                    if bytes.iter().as_slice() == response {
                        info!("Response matches expected response.");
                    } else {
                        error!("Response does not match expected response.");
                    }
                }
                Err(error) => error!("Got error: {error:?}"),
            }
        }
    }

    transceiver_thread
        .join()
        .expect("Transceiver thread panicked.");
}
