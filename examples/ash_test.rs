//! Test `ASHv2` connection.

use ashv2::{open, BaudRate, SyncAsh, Transceiver};
use clap::Parser;
use log::{error, info, warn};
use serialport::{FlowControl, SerialPort};
use std::sync::atomic::AtomicBool;
use std::sync::mpsc::{channel, sync_channel, Receiver};
use std::sync::Arc;
use std::thread::spawn;

const COMMANDS: [(&[u8], &[u8]); 0x1A] = [
    // Version (legacy frame format) command
    (
        &[0x00, 0x00, 0x00, 0x04],
        &[0x00, 0x80, 0x00, 0x08, 0x02, 0x30, 0x6A],
    ),
    // Version (new frame format) command
    (
        &[0x01, 0x00, 0x01, 0x00, 0x00, 0x08],
        &[0x01, 0x80, 0x01, 0x00, 0x00, 0x08, 0x02, 0x30, 0x6A],
    ),
    // getStandaloneBootloaderVersionPlatMicroPhy command
    (
        &[0x02, 0x00, 0x01, 0x91, 0x00],
        &[0x02, 0x80, 0x01, 0x91, 0x00, 0x00, 0x1C, 0x04, 0x18, 0x0F],
    ),
    // Diverse getConfigurationValue commands
    (
        &[0x03, 0x00, 0x01, 0x52, 0x00, 0x1A],
        &[0x03, 0x80, 0x01, 0x52, 0x00, 0x00, 0xC8, 0x00],
    ),
    (
        &[0x04, 0x00, 0x01, 0x52, 0x00, 0x0D],
        &[0x04, 0x80, 0x01, 0x52, 0x00, 0x00, 0x05, 0x00],
    ),
    (
        &[0x05, 0x00, 0x01, 0x52, 0x00, 0x05],
        &[0x05, 0x80, 0x01, 0x52, 0x00, 0x00, 0x08, 0x00],
    ),
    (
        &[0x06, 0x00, 0x01, 0x52, 0x00, 0x19],
        &[0x06, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x07, 0x00, 0x01, 0x52, 0x00, 0x0C],
        &[0x07, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x08, 0x00, 0x01, 0x52, 0x00, 0x12],
        &[0x08, 0x80, 0x01, 0x52, 0x00, 0x00, 0xB8, 0x0B],
    ),
    (
        &[0x09, 0x00, 0x01, 0x52, 0x00, 0x10],
        &[0x09, 0x80, 0x01, 0x52, 0x00, 0x00, 0x1E, 0x00],
    ),
    (
        &[0x0A, 0x00, 0x01, 0x52, 0x00, 0x17],
        &[0x0A, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x0B, 0x00, 0x01, 0x52, 0x00, 0x2D],
        &[0x0B, 0x80, 0x01, 0x52, 0x00, 0x00, 0x01, 0x00],
    ),
    (
        &[0x0C, 0x00, 0x01, 0x52, 0x00, 0x1E],
        &[0x0C, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0C, 0x00],
    ),
    (
        &[0x0D, 0x00, 0x01, 0x52, 0x00, 0x2A],
        &[0x0D, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x0E, 0x00, 0x01, 0x52, 0x00, 0x11],
        &[0x0E, 0x80, 0x01, 0x52, 0x00, 0x00, 0x20, 0x00],
    ),
    (
        &[0x0F, 0x00, 0x01, 0x52, 0x00, 0x03],
        &[0x0F, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0A, 0x00],
    ),
    (
        &[0x10, 0x00, 0x01, 0x52, 0x00, 0x2B],
        &[0x10, 0x80, 0x01, 0x52, 0x00, 0x00, 0x0F, 0x00],
    ),
    (
        &[0x11, 0x00, 0x01, 0x52, 0x00, 0x04],
        &[0x11, 0x80, 0x01, 0x52, 0x00, 0x00, 0x20, 0x00],
    ),
    (
        &[0x12, 0x00, 0x01, 0x52, 0x00, 0x02],
        &[0x12, 0x80, 0x01, 0x52, 0x00, 0x00, 0x10, 0x00],
    ),
    (
        &[0x13, 0x00, 0x01, 0x52, 0x00, 0x1C],
        &[0x13, 0x80, 0x01, 0x52, 0x00, 0x00, 0x01, 0x00],
    ),
    (
        &[0x14, 0x00, 0x01, 0x52, 0x00, 0x1D],
        &[0x14, 0x80, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00],
    ),
    (
        &[0x15, 0x00, 0x01, 0x52, 0x00, 0x01],
        &[0x15, 0x80, 0x01, 0x52, 0x00, 0x00, 0xFA, 0x00],
    ),
    // Diverse getPolicy commands
    (
        &[0x16, 0x00, 0x01, 0x56, 0x00, 0x00],
        &[0x16, 0x80, 0x01, 0x56, 0x00, 0x00, 0x03],
    ),
    (
        &[0x17, 0x00, 0x01, 0x56, 0x00, 0x01],
        &[0x17, 0x80, 0x01, 0x56, 0x00, 0x00, 0x10],
    ),
    (
        &[0x18, 0x00, 0x01, 0x56, 0x00, 0x04],
        &[0x18, 0x80, 0x01, 0x56, 0x00, 0x00, 0x40],
    ),
    (
        &[0x19, 0x00, 0x01, 0x56, 0x00, 0x05],
        &[0x19, 0x80, 0x01, 0x56, 0x00, 0x00, 0x50],
    ),
];

const LONG_COMMAND: [u8; 256] = [0xAA; 256];

#[derive(Debug, Parser)]
struct Args {
    #[arg(index = 1)]
    tty: String,
}

struct InlineBytes<'a>(&'a [u8]);

impl std::fmt::Display for InlineBytes<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let max_index = self.0.len().saturating_sub(1);
        write!(f, "[")?;

        for (index, byte) in self.0.iter().enumerate() {
            if index == max_index {
                write!(f, "{byte:#04X}")?;
            } else {
                write!(f, "{byte:#04X}, ")?;
            }
        }

        write!(f, "]")
    }
}

fn main() {
    env_logger::init();
    let args = Args::parse();

    match open(args.tty, BaudRate::RstCts, FlowControl::Software) {
        Ok(serial_port) => run(serial_port),
        Err(error) => error!("{error}"),
    }
}

fn run(serial_port: impl SerialPort + 'static) {
    let (host, receiver) = channel();
    let (callback_tx, callback_rx) = sync_channel(1);
    let transceiver = Transceiver::new(serial_port, receiver, Some(callback_tx));
    let running = Arc::new(AtomicBool::new(true));
    let callback_thread = spawn(|| receive_callbacks(callback_rx));
    let transceiver_thread = spawn(|| transceiver.run(running));

    for (command, response) in COMMANDS {
        info!("Sending command: {}", InlineBytes(command));

        match host.communicate(command) {
            Ok(bytes) => {
                info!("Got response: {}", InlineBytes(&bytes));

                if bytes.iter().as_slice() == response {
                    info!("Response matches expected response.");
                } else {
                    error!("Response does not match expected response.");
                }
            }
            Err(error) => error!("Got error: {error:?}"),
        }
    }

    match host.communicate(&LONG_COMMAND) {
        Ok(response) => info!("Got response for long command: {}", InlineBytes(&response)),
        Err(error) => error!("Got error: {error:?}"),
    }

    callback_thread.join().expect("Callback thread panicked.");
    transceiver_thread
        .join()
        .expect("Transceiver thread panicked.");
}

fn receive_callbacks(receiver: Receiver<Box<[u8]>>) {
    info!("Receiving callbacks.");

    loop {
        match receiver.recv() {
            Ok(callback) => warn!("Got callback: {}", InlineBytes(&callback)),
            Err(error) => error!("Got error: {error}"),
        }
    }
}
